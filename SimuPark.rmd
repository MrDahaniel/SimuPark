# **SimuPark: Simulando Un Parque De Diversiones**

- Paula Catalina Hernández Ramírez 2180048 - Moderador
- Juan Pablo Claro Pérez - 2181707 - Relator
- Daniel David Delgado Cervantes - 2182066 - Expositor

## **Resumen**

El presente documento examina una problemática que se presenta en cualquier lugar donde se encuentre una cantidad excesiva de personas y haya la necesidad de hacer filas. La teoría de colas es un estudio matemático que busca entender el comportamiento de las líneas de espera dentro de un sistema, donde el cliente presenta una solicitud para que se le presten un servicio y este a su vez dependerá de una variante, la demanda, ya que con esta se determina el tiempo de espera que debe tener la persona hasta obtener lo que requiere. El ecosistema a estudiar se presenta dentro
de los parques de diversiones, en los cuales se presentan problemas a la hora de ingresar a diferentes atracciones, donde las personas pueden durar mucho mas tiempo realizando las colas que divirtiéndose en los juegos. Situación que además de desafortunada para el cliente, también lo será para el parque de diversiones, pues entre más cómoda sea la espera a las atracciones, mayores serán las probabilidades de que la persona quiera volver al parque. Es por ello que se plantea: ¿Existirá alguna forma para que las personas puedan divertirse más y así disminuir el tiempo de espera en las diferentes atracciones?

## **Introducción**

La teoría de líneas de espera inicia con el trabajo de Agner Krarup Erlang matemático Danés, el cual en el estudio de líneas telefónicas obtuvo la fórmula para la distribución del número de líneas de espera, a partir de aquí la teoría de colas se aplica en un sinfín de estudios encargados del comportamiento de sistemas como el tráfico automovilístico, las filas de un banco o el flujo de mensaje.

El objetivo principal de la teoría de colas es modelar el sistema que presenta estas líneas de espera, con el fin de observar el comportamiento y posibles alternativas de solución para obtener el resultado más optimo según el estudio que se realice. Teniendo esto presente, la teoría de colas será fundamental para el desarrollo del estudio, este se centrará en el sistema que conforma un parque de diversiones, donde se concentra una población grande de personas, las cuales desean probar cada atracción presente.

Este sistema a estudiar presenta múltiples variables ya que no se van a presentar los mismos escenarios, puede influir ya sea la hora del día, un fecha especial en el año, el clima, los precios de cada una de las atracciones, la fama de cada juego, entre otras. Las ferias encargadas de los parques de diversiones han aplicado una transformación al sistema donde se usa el Fast Pass, este es un método para agilizar las colas, pero ¿Es efectivo? ¿Las personas invierten menos tiempo en esperas y más en divertirse?

## **Formulación Del Problema**

Uno de los principales problemas que se presentan en cualquier tipo de cola, o fila, está en el tiempo de espera que implica estar en estas. Este tiempo de espera depende de 2 variables: la tasa de servicio, o el tiempo en el cual sale gente de la fila; y la tasa de llegada, que se refiere a la velocidad con la que ingresan personas a la fila. Es a partir de esto que funcionan todas las colas.

Los parques de diversiones son centros de recreación que atraen a multitudes de personas que desean disfrutar de las distintas gamas de atracciones que se manejan. Siendo así, uno de los problemas a los que tienen que enfrentarse tanto los visitantes son las largas colas que se pueden presentar en muchas de las atracciones. Esto, en el peor de los casos, puede generar descontento en los visitantes debido a la gran cantidad de tiempo que perdieron esperando, lo que a la larga, podría afectar la reputación del parque y las ganancias del mismo.

Partiendo de esto, el problema que se busca solucionar son estas mismas colas, y las diferentes técnicas que se pueden emplear para poder reducir el tiempo de espera promedio de los visitantes. De esta manera, se busca mejorar la experiencia general del público asistente que, en respuesta, implicaría una mejora de los ingresos generados por el parque.

## **Objetivos**

### **Objetivo General**

-   Analizar el comportamiento de las filas de las atracciones de un parque de diversiones a partir de simulaciones computacionales para determinar qué estrategias son más efectivas para la reducción del tiempo de espera promedio.

### **Objetivos Específicos**

-   Determinar qué estrategia conlleva la mayor reducción del tiempo de espera en las colas del parque.
-   Identificar los diferentes factores que se relacionan con el tiempo de espera promedio de cada una de las atracciones del parque.
-   Determinar las diferentes limitaciones que presenta el parque en cuanto el manejo de las colas de cada una de sus atracciones.
-   Analizar qué tanto se puede incrementar el flujo de visitantes a un parque de diversiones y si la cantidad de atracciones en las que se subieron aumentó con un cambio de estrategia _FastPass_.

## **Conceptualización del modelo**

El modelo empleado como punto de partida en el estudio de la simulación del comportamiento de las colas de espera presentadas en un parque de atracciones se puede ver simplificado en el siguiente diseño, el cual cuenta con ciertos componentes en los que se involucra la conducta o 'arquetipo' de cada persona a la hora de recurrir a las diferentes atracciones, las actividades que la persona podría elegir, las atracciones, y muchas más variables que influirán en la ejecución de la simulación:

<p align="center">
  <img src="https://imgur.com/hfCMmYT.png" />
</p>

Se inicia con el estudio de las diferentes personas, sus gustos y arquetipos para obtener una lectura que permita crear un mapa global de cada una de las distintas opciones que puede elegir las personas, tomando el arquetipo como punto de partida para obtener los gustos que pueden presentar los visitantes en el modelo.

El parque de atracciones contará con la entidad de actividades que determina cada una de las opciones que pueden seleccionar las personas, teniendo en consideración que cada actividad presente puede ser una atracción distinta, la cual cuenta con tiempo de espera y un tiempo de servicio en la que cada persona puede participar.

El concepto estudiado en modelo parte desde un caso base presente en cada uno de los parque de atracciones en el cual no se emplean técnicas para mejorar la conducta de las colas sino empleando el sistema FIFO, este caso base se centra en un flujo donde la persona al ingresar al parque selecciona si desea realizar una actividad o si por el contrario decide emplear tiempo en la cola de espera de una de las atracciones para disfrutar de ella, luego de esto la persona decide si desea realizar otra actividad o ingresar a otra atracción hasta que esta decida irse, teniendo como resultado el siguiente diagrama:

<p align="center">
  <img src="https://imgur.com/gCywLid.png" />
</p>

A su vez se desea comparar este modelo tradicional del funcionamiento de los parques de atracciones con otros modelos que emplean tácticas para que sus sistemas de espera faciliten la movilidad de los usuarios, teniendo presente esto, el modelo con un diseño como el del SalitrePass presenta una modificación en los tiempos de espera presente en cada una de las atracciones. La persona puede elegir si entrar a una fila normal o la fila perteneciente al SalitePass, esto depende del tiempo de espera presentante en cada una y de la decisión de la persona.

<p align="center">
  <img src="https://imgur.com/uJwzvGn.png" />
</p>

Otro modelo de comparación es el empleado en los parques de diversiones de Disney donde presentan una facilidad llamada _FastPass_ donde la persona que presenta el _FastPass_ debe presentarse frente a la atracción a la hora especificada en el comprobante, esto con el fin de que la persona no realice filas sino que ingrese directamente a la atracción o actividad, de lo contrario decidirá si quiere unirse a la fila, comprar un _FastPass_ para la atracción o realizar otra actividad, teniendo como resultado el siguiente flujo:

<p align="center">
  <img src="https://imgur.com/LNKBfEc.png" />
</p>

## **Desarrollo**

### **Recolectando Y Procesando Datos**

Una de las partes más importantes en cuanto se refiere a la construcción de nuestro modelo de simulación, está en la recolección de los datos necesarios para poder estar lo más cerca a el comportamiento real. En este caso, esto no es la excepción.

Para poder realizar el modelado de las diferentes componentes del parque de diversiones de nuestra simulación, requeríamos conocer, o por lo menos aproximar, 3 parámetros los cuales afectan de gran medida los resultados finales. La función de llegada de los visitantes al parque, la cual determina la cantidad de personas que llegan a parque dependiendo la hora del día; los arquetipos de las personas, los cuales determinan el comportamiento de las personas ya en el parque; y las principales caracterísitcas de las atracciones, principalmente la tasa de servicio y la popularidad de las mismas. Siendo así, se llevaron acabo diferentes procedimientos para la determinación de estos parámetros.

#### **Determinando La Función De Entrada Al Parque**

La principal necesidad de determinar la función que describa el comportamiento de la entrada de las personas al parque, está en el como este afecta los tiempos de espera de manera general dentro del parque.

Lo primero a realizar es cargar nuestro dataset. Como tal, este dataset fue recolectado de diferentes páginas web las cuales indicaban una especie de nivel de "llenura". Aunque se han de reconocer las limitaciones de la información que verdaramente provee, debido a la escacez de los datos que hay sobre las tasas de entrada en muchos de los parques, es lo más cercano que se tiene a un reporte de la manera en la que las personas visitan el parque.

```{r}
entry_df <- read.table("https://gitlab.com/MrDahaniel/proyecto-simulacion/-/raw/main/datasets/crowdLevelsMagicKindom.csv", header = T)

knitr::kable(head(entry_df))
```

Eliminamos la fila del nombre del parque.

```{r, message=FALSE}
entry_df <- entry_df[, 2:18]

entry_df <- reshape2::melt(entry_df)
entry_df$variable <- as.numeric(sub("X", "", entry_df$variable)) - 8
```

```{r, echo = FALSE, fig.align='center', fig.height=5, fig.width=10}
plot(entry_df)
```

```{r}
lm_model <- lm(formula = value ~ poly(variable, 7, raw = TRUE), data = entry_df)
```

```{r, echo = FALSE}
lm_model
```

Ya a partir de estos coeficientes calculados por la función `lm`, podemos convertir el modelos a su forma de ecuación polinómica el modelo propuesto.

```{r, echo = FALSE}
model_fn <- function(x, coef) {
  y <- 0
  dg <- 0
  for (co in coef) {
    y <- y + (co * (x**dg))
    dg <- dg + 1
  }
  return(y)
}

print_model <- function(coef) {
  y <- "0"
  dg <- 0
  for (co in coef) {
    y <- paste(y, "+ (", co, ") * ( x **", dg, ")")
    dg <- dg + 1
  }
  print(y, quote = FALSE)
}
```

```{r, echo = FALSE}
print_model(lm_model$coefficients)
```

Y a partir de esto, podremos realizar la visualización del modelos planteado y ver el ajuste de este con respecto a los datos que se tienen.

```{r, echo=FALSE, fig.align='center', fig.height=5, fig.width=10}
plot(entry_df, main = 'Niveles de "llenura"', xlab = "Tiempo", ylab = "Nivel")
curve(model_fn(x, lm_model$coefficients), from = 0, to = 16, add = TRUE)
```

Será a partir de este modelo por el cual se definirá la entrada de las personas al parque. Esto tiene una gran importancia pues es a partir de esto que se definirá tanto la cantidad de visitantes al parque como el estos van llegando.

#### **Definiendo Los Arquetipos De Los Visitantes** 

Carguemos nuestro dataset relacionado con las respuestas recolectadas.

```{r}
forms_df <- read.csv("https://gitlab.com/MrDahaniel/proyecto-simulacion/-/raw/main/datasets/formResponses.csv")[2:10]
```

```{r, echo = FALSE}
knitr::kable(head(forms_df))
```

Ya con estos datos disponibles, debemos determinar 3 componentes princiaples para poder definir cada uno de los arquetipos de los visitantes al parque. El primero de estos está en la preferencia de realizar una actividad sobre una atracción. En este sentido, tendremos que basarnos sobre las respuestas relacionadas con los gustos de las personas.

##### **Probabilidad De Atracciones Sobre Actividades**

```{r}
preference_df <- forms_df[1:5]
```

```{r, echo = FALSE}
knitr::kable(head(preference_df))
```

Lo primero que vamos a hacer con el fin de definir los porcentajes de preferencia de las personas estará en promediar el valor de cada una de las actividades. De esta manera, tendremos el valor general de que estos realicen una activiadad. Partiendo de esto, sólo queda sacar la fracción entre el valor de la atracción sobre la suma del puntaje promedio de las activiades con el puntaje de la atracción para tener un aproximado de las preferencias de las personas.

```{r}
preference_df$PromAct <- rowMeans(preference_df[, c(1, 2, 4, 5)])
preference_df$ProbAttr <- (preference_df[, 3]) / (preference_df[, 3] + preference_df[, 6])
```

```{r, echo = FALSE}
knitr::kable(head(preference_df))
```

Entonces, a partir de esto, podemos encontrar los cuantiles de nuestros promedios para poder tomar los valores base de las probabilidades de escoger una atracción sobre una actividad, De esta manera, podremos podremos definir más adelante nuestros arquetipos para los visitantes del parque.

```{r}
quantiles <- quantile(preference_df$ProbAttr)
```

```{r, echo = FALSE}
quantiles
```

A partir de estos 5 cuantiles, podemos definir los valores generales de la probabilidad de escoger una atracción sobre una actividad. Siendo así, y teniendo en cuenta que los cuartiles de 25%, 50% y 75 son relativamente similares, se trabajarán con un total de 3 probabilidades para el desarrollo de la simulación.

#### **Tiempos De Espera Y Estadía**

Ya teniendo definidas las diferentes probabilidades de escoger las atracciones, nos queda por definir los diferentes tiempos tanto de estadía el parque. Estos tiempos, nuevamente, serán definidos por las diferentes respúestas recibidas en la encuesta realizada.

Empecemos determinando los tiempos de espera máximos para cada uno de los arquetipos. Lo primero que haremos será determinar los porcentajes que representa cada uno de los intervalos que se han definido

```{r}
wait_df <- forms_df[8]
reps <- cbind(table(wait_df))
reps <- unname(cbind(reps, row.names(reps)))
reps <- data.frame(reps)

colnames(reps) <- c("repeticiones", "tiempo_espera")

t_espera <- c()
total_respuestas <- nrow(wait_df)

for (i in 1:nrow(reps)) {
  t_espera <- c(t_espera, as.integer(reps[i, 1]) / total_respuestas)
}


reps$porcentaje <- cbind(t_espera)
```
```{r, echo=FALSE}
knitr::kable(reps)
```

Apliquemos este mismo proceso para determinar los tiempos de estadía dentro del parque.

```{r}
wait_df <- forms_df[6]
reps <- cbind(table(wait_df))
reps <- unname(cbind(reps, row.names(reps)))
reps <- data.frame(reps)

colnames(reps) <- c("repeticiones", "tiempo_estadia_min")

t_espera <- c()
total_respuestas <- nrow(wait_df)

for (i in 1:nrow(reps)) {
  t_espera <- c(t_espera, as.integer(reps[i, 1]) / total_respuestas)
}

reps$porcentaje <- cbind(t_espera)
```

```{r, echo=FALSE}
knitr::kable(reps)
```

```{r}
wait_df <- forms_df[7]
reps <- cbind(table(wait_df))
reps <- unname(cbind(reps, row.names(reps)))
reps <- data.frame(reps)

colnames(reps) <- c("repeticiones", "tiempo_estadia_max")

t_espera <- c()
total_respuestas <- nrow(wait_df)

for (i in 1:nrow(reps)) {
  t_espera <- c(t_espera, as.integer(reps[i, 1]) / total_respuestas)
}

reps$porcentaje <- cbind(t_espera)
```

```{r, echo=FALSE}
knitr::kable(reps)
```

A apartir de estos datos, se llegó a la determinación de lo siguientes arquetipos con los cuales se trabajará durante la simulación. Estos se encuentran en `constants.py` que es el que se encarga del manejo de esos datos.

```py
ARCHETYPES = {
    "Tourist": {
        "AttractionPercentage": 0.6,
        "MinStayTime": 4 * 60,
        "MaxStayTime": 8 * 60,
        "WaitTime": 60,
    },
    "Average": {
        "AttractionPercentage": 0.5,
        "MinStayTime": 4 * 60,
        "MaxStayTime": 8 * 60,
        "WaitTime": 50,
    },
    "Activity Enjoyer": {
        "AttractionPercentage": 0.2666667,
        "MinStayTime": 1 * 60,
        "MaxStayTime": 5 * 60,
        "WaitTime": 10,
    },
    "Attraction Enjoyer": {
        "AttractionPercentage": 0.7407407,
        "MinStayTime": 4 * 60,
        "MaxStayTime": 9 * 60,
        "WaitTime": 70,
    },
    "All Day Guest": {
        "AttractionPercentage": 0.6,
        "MinStayTime": 8 * 60,
        "MaxStayTime": 12 * 60,
        "WaitTime": 40,
    },
    "Relaxed Visitor": {
        "AttractionPercentage": 0.4,
        "MinStayTime": 3 * 60,
        "MaxStayTime": 6 * 60,
        "WaitTime": 25,
    },
}
```

#### **Compras Del _FastPass_ de Salitre**

Ahora, lo último que nos queda en término del tratamiento de datos respecto a los datos recolectados en la encuesta, está en determinar el porcentaje de personas que pagarían el costo extra del _FastPass_ para el escenario de Salitre. En este sentido, se definirá el porcentaje de personas que estarían dispuestas a pagar un precio en especial. 

Tomemos la cantidad de personas por cada uno de los precios que se definieron en la encuesta: 

```{r}
# Traemos la columna relacionada
fastpass_df <- forms_df[9]


no_compra <- length(fastpass_df[fastpass_df == "Ninguna de las anteriores"])
p1030 <- length(fastpass_df[fastpass_df == "$10.000-$30.000"])
p3050 <- length(fastpass_df[fastpass_df == "$30.000-$50.000"])
p50p <- length(fastpass_df[fastpass_df == "Mas de $50.000"])
```

```{r, echo=FALSE}
categoria <- c(
  "Ninguna de las anteriores", "Entre $10.000 y $30.000",
  "Entre $30.000 y $50.000", "Mas de $50.000"
)
total <- no_compra + p1030 + p3050 + p50p
frecuencia <- c(no_compra, p1030, p3050, p50p)
porcentaje <- frecuencia / total
porcentaje_compra <- c(sum(porcentaje[c(4, 3, 2, 1)]), sum(porcentaje[c(4, 3, 2)]), sum(porcentaje[c(4, 3)]), sum(porcentaje[c(4)]))

knitr::kable(cbind(
  categoria,
  frecuencia,
  porcentaje,
  porcentaje_compra
))
```

#### **La Popularidad, Duración Y La Tasa De Servicio De Las Atracciones**

Ya saliendo de las encuestas, pasamos a nuestro valores definidos ya como tal. Partamos por las tasas de servicio de las atracciones con las que estaremos trabajando. De manera oficial, no existen como tal registros de las tasas de servicio para ninguna de las atracciones dentro de los parques de Disney, por este motivo, se tuvo que recurrir a estimaciones realizadas por los visitantes del parque. Una de estas fuentes, [wdwthemeparks.com](https://wdwthemeparks.com/hourly-capacity-numbers/), nos presenta con una gran mayoría de los tiempos de espera para los algunos de los parque de atracciones de Disney. 

De manera similar, tenemos que definir el tiempo de duración de las atracciones. Estos tiempos definen tanto el periodo de inactividad de los visitantes como el de las atracciones. De igual manera, al no poder tomar datos directamente de los parques a trabajar, se emplearon reportes de diferentes visitantes al parque publicados en internet. En este caso, se están usando los valores reportados por [touringplans.com](https://touringplans.com/animal-kingdom/attractions/duration#).

Para el desarrollo de este ejercicio, se tomará como referencia el parque de Animal Kingdom, esto principalmente a que es el parque con los datos más completos dentro todos los que se tienen disponibles. Siendo así, en la simulación se trabajarán con las siguientes atracciones:

```{r, echo=FALSE}
attractions <- c(
  "DINOSAUR", "Expedition Everest", "Flight of Passage",
  "Kali River Rapids", "Kilimanjaro Safaris", "Na'vi River Journey",
  "TriceraTop Spin"
)
service_rates <- c(
  "1800", "1800-2060", "1280-1440", "1800-2000",
  "3000", "1080-1440", "800-900"
)
duration <- c(
  4, 4, 6, 10, 20, 5, 2
)

knitr::kable(cbind(attractions, service_rates, duration))
```

Ahora, en cuanto a la popularidad de cada una de las atracciones, se calculó un valor aproximado de esta definido a partir de la multiplicación de 2 factores. El primero de estos, es la misma tasa de servicio definida en el punto anterior y el segundo de estos es el tiempo de espera mensual promedio reportado por algunos de los servicios como lo son [thrill-data.com](https://www.thrill-data.com/waits/park/wdw/animal-kingdom/). A partir de esto tendremos un estimado del verdadero interés de una atracción en especial al tener en cuenta tanto que tanto hay que esperar en promedio para la atracción, lo que refleja el interés de los visitantes, y la tasa de servicio lo cual evita tiene en cuenta el como se relacionan estos tiempos de espera con la velocidad con la que se atienden a las personas.

Siendo así, para cada uno de las atracciones, estos serían los datos con los que estaríamos trabajando.

```{r, echo=FALSE}
reported_wait_times <- c(
  33, 26, 98, 29, 48, 70, 15
)

popularity <- c(
  33 * 1800, 26 * 1800, 98 * 1280, 29 * 1800, 48 * 3000, 70 * 1080, 15 * 800
)

knitr::kable(
  cbind(attractions, service_rates, duration, reported_wait_times, popularity)
)
```
   
En el momento de realizar la elección de que atracción será para la cual hará fila, se calcula el porcentaje de popularidad que representa el términos generales cada una de las atracciones.

### **Implementación De La Simulación**

Para el desarrollo del prototipo para la simulación, se partió de lo que se definió inicialmente durante la fase de la conceptualización del modelo. Siendo así, tenemos los siguientes módulos:

El primero de estos es el módulo de `Park`, de manera general, este es nuestro componente principal pues engloba en si todos los demás componentes de la simulación. Hay que resaltar que, además de manejar la creación y menejo de los arquetipos, atracciones y actividades; este se encarga de como tal realizar la simulación del parque con el uso de la función `Park.start_day(self, max_entry_rate, wait_time_update)`.

```py
class Park:
    def __init__(
        self,
        attraction_dict: dict[str, dict] = ATTRACTIONS,
        activities_dict: dict[str, dict] = ACTIVITIES,
        archetype_dict: dict[str, dict] = ARCHETYPES,
        fn: Callable[[float], float] = lambda x, k: k ** x * np.exp(-k) / gamma(x + 1),
        hours_open: int = 16,
        fastpass_pool_size: float = 0.3,
    ) -> None:
        self.current_time: int = 0
        self.closing_time: int = 60 * hours_open
        self.attractions: list[Attraction] = self._handle_attractions(
            attraction_dict=attraction_dict,
            alt_queue=None,
            hours_open=hours_open,
            fastpass_pool_size=fastpass_pool_size,
        )
        self.activities: list[Activity] = self._handle_activities(activities_dict)
        self.guest_archetypes: list[Archetype] = self._handle_archetypes(archetype_dict)
        self.guests: list[Union[Person, DisneyPerson]] = []
        self.function: Callable[[float], float] = fn
```

Así mismo, es a partir de la herencia de `Park` por el cual se realizan las diferentes implementaciones de nuestros diferentes casos alternos. En estos casos, los cambios más relevantes están principalmente en la función `start_day` al igual que algunas de las funciones auxiliares como `Park._update_fake_wait_time(self)` la cual varía en cada una de las implementaciones.

De manera un poco más interna, se implementaron los componenetes de `Activity` y `Attraction`. Estos, en especial `Attraction`, son los encargados del manejo de sus filas, al igual que el atender a las personas que las visitan. 

```py
class Activity:
    def __init__(self, name: str, popularity: int, duration: int) -> None:
        self.name: str = name
        self.duration: int = duration
        self.popularity: int = popularity


class Attraction(Activity):
    def __init__(
        self,
        name: str,
        popularity: int,
        duration: int,
        service_rate: int,
        alt_queue: str = None,
        hours_open: int = 16,
        fastpass_pool_size: float = 0.3,
        fastpass_serve_size: float = 0.6,
    ) -> None:
        super().__init__(name, popularity, duration)
        self.service_rate: int = service_rate
        self.fake_wait_time: int = 0
        self.queue: Queue = Queue()
        self.fastpass_serve_size: float = fastpass_serve_size

        self.time_until_service: int = duration

        self.total_people_served: int = 0

        if alt_queue in ["DFP", "SFP"]:
            self.alt_queue: Queue = Queue(type=alt_queue)
            self.queue: TotalQueue = TotalQueue()

            if alt_queue == "DFP":
                self.fast_pass_machine: FastPassMachine = FastPassMachine(
                    attraction_name=name,
                    service_rate=service_rate,
                    hours_open=hours_open,
                    fastpass_pool_size=fastpass_pool_size,
                )
```

La creación de instancias de estos módulos durante la simulación viene dada desde el parque. Las funciones más importantes dentro de `Attraction` es la función `Attraction.serve(self)` y `Attraction.serve_with_fastpass(self)` debido a que estas son las encargadas de llamar a las filas para que atiendan a las peronas presentes en las filas.

En cuanto a las visitantes del parque, se implementó el módulo `Person`, el cual se encarga del manejo tanto de las caracterísitcas de las personas al igual que el comportamiento de las mismas en el momento de decir que harán en cuanto a atracciones y actividade y el cuanto están dispuestas a esperar en una fila. 

```py
class Person:
    def __init__(
        self,
        id: int,
        arrival_time: int,
        archetype: Archetype,
        park_closing_time: int = None,
    ) -> None:
        # General info
        self.id: str = id
        self.time_left_in_activity: int = 0
        self.current_activity: str = None

        # Used for statistics
        self.attractions_experienced: int = 0
        self.total_wait_time: int = 0
        self.arrival_time: int = arrival_time
        self.things_done: list[str] = []
        self.queues_joined: int = 0

        # Archetype defined
        self.archetype: str = archetype.name
        self.departure_time: int = (
            randint(archetype.min_stay, archetype.max_stay) + arrival_time
        )
        self.max_wait: int = randint(archetype.min_wait_time, archetype.max_wait_time)
        self.attraction_chance: float = archetype.attraction_chance

        # Handle time after park closes
        if park_closing_time is not None and park_closing_time < self.departure_time:
            self.departure_time = park_closing_time
```

Para cada una de las implementaciones alternas que se realizaron, se creó a partir de herencia un tipo de persona específico para cada uno de los diferentes escenarios. Esto se debe principalmente a que el comportamiento de las personas dentro del parque cambiaba dependiendo del escenario que se estaba trabajando. Siendo así, la función principal de `Person` sería `Person.check_attraction` pues es la que define el comportamiento de las personas dentro del parque en altera la manera de decidir sobre si espera o no en una fila.

### **Diseño Experimental**

Durante el desarrollo de la simulación se identificaron una serie de tres alternativas, para ser comparadas con el caso base. Los cuatro escenarios a simular cuentan con estas características en común: la persona que ingrese al parque podrá escoger entre actividad (acción para la cual no necesita hacer ninguna fila),  o atracción (acción para la que tendrá un tiempo de espera y por lo tanto tendrá que hacer fila). Y si la persona se decide por una atracción, será su arquetipo, es decir una serie de datos que determinarán su decisión, el que indicará si la persona escoge hacer fila por esa atracción o si mejor toma otra decisión (actividad o atracción).

Sintetizando, son cuatro escenarios en total los que se pondrán a prueba en la simulación (contando el caso base). Se describen a continuación:

Caso Base: En este escenario la persona ingresará al parque y tendrá la opción de escoger entre una actividad que podrá hacer inmediatamente, o una atracción para la que deberá esperar haciendo fila. Este sería el caso con el que cuenta un parque de atracciones sin implementar algún tipo de ticket especial o preferencial, que tendrá un mayor costo para el visitante y que en nuestro artículo se ha decicido nombrar como *'fast pass'*.

Caso _FastPass_ Disney: En este escenario la persona ingresará al parque y tendrá la opción de realizar una actividad que al igual que en el caso base y en los demás, podrá hacer al instante, o podrá escoger una atracción. En caso de escoger la atracción pueden ocurrir dos situaciones, que la persona posea _FastPass_ para cierta hora, es decir, a determinada hora del día pueda pasar sin hacer fila, o podrá no tener _FastPass_ y según si quiere esperar haciendo fila o no (dependiendo de su arquetipo), podrá subirse a la atracción que escogió. Para el caso _FastPass_ se decidió que de las personas que llegaran al parque solo el 30% pudieran adquirir un _FastPass_.

Caso _FastPass_ Salitre: En este escenario la persona ingresará al parque y tendrá que escoger entre actividades y atracciones. La diferencia radica en que el _FastPass_ de Salitre es un ticket cuyo precio es mayor al normal, y le permite a la persona ingresar a una fila virtual para omitir la normal, y así poder disminuir su tiempo de espera en cola.

Caso Tiempos Falsos: En este escenario a simular las personas siguen el mismo comportamiento que tendrían en el caso base. La diferencia se encuentra en que los tiempos de espera mostrados a la persona que escoge cierta atracción, estarán aumentados según el rango de tiempo en el que se halle el tiempo de espera de tal atracción, con el fin de disuadir a las personas de hacer la fila y así reducir los tiempos de colas para las atracciones.


### **Resultados de la Simulación**

Para tratar de tener varios días de cada parque, se simularon un totol de 7 días para cada unode los escenarios los cuales trabajaron. Esto se realizó con el fin de tratar de tener varios días con los que trabajar en cuanto al análisis de resultados. En total, esto nos dió un total de alrededor de 800000 registros en total, aproximadamente 200000 para cada una de los casos trabajados. El reportar estos datos en una tabla para poder sacar conclusiones, aunque posible, es realmente complicado pues no es la mejor manera de condensar los datos.

Siendo así, empecemos revisando los tiempos de espera promedio de cada una de los escenarios.

#### **Tiempos De Espera**

```{r}
base_df <- read.csv("https://gitlab.com/MrDahaniel/proyecto-simulacion/-/raw/main/datasets/BASE.csv")
dfp_df <- read.csv("https://gitlab.com/MrDahaniel/proyecto-simulacion/-/raw/main/datasets/DFP.csv")
sfp_df <- read.csv("https://gitlab.com/MrDahaniel/proyecto-simulacion/-/raw/main/datasets/SFP.csv")
ftp_df <- read.csv("https://gitlab.com/MrDahaniel/proyecto-simulacion/-/raw/main/datasets/FTP.csv")
```

```{r, echo=FALSE}
print("Caso Base")
knitr::kable(head(base_df))
print("Disney FastPass")
knitr::kable(head(dfp_df))
print("Salitre FastPass")
knitr::kable(head(sfp_df))
print("Tiempos Falsos")
knitr::kable(head(ftp_df))
```

Ya con los datos cargados, miremos los tiempos de espera promedio para aquellas personas que pudieron subirse aunque sea a una atracción. En el caso de no tener esta consideración, estaríamos añadiendo datos que no deberíamos considerar a los resultados.

```{r, echo=FALSE}
print(paste("Promedio tiempo de espera (Caso Base)", mean(base_df$average_wait_time[base_df$attractions_experienced != 0])))
print(paste("Promedio tiempo de espera (Disney FastPass)", mean(dfp_df$average_wait_time[dfp_df$attractions_experienced != 0])))
print(paste("Promedio tiempo de espera (Salite FastPass)", mean(sfp_df$average_wait_time[sfp_df$attractions_experienced != 0])))
print(paste("Promedio tiempo de espera (Tiempos Falsos)", mean(ftp_df$average_wait_time[ftp_df$attractions_experienced != 0])))
```

Veamos de manera gráfica la distribución de estos tiepos de espera.

```{r, echo=FALSE, fig.align='center', fig.width=10, fig.height=7}
par(mfrow = c(2, 2))
hist(base_df$average_wait_time[base_df$attractions_experienced != 0], main = "Caso Base", xlab = "Tiempo Espera Promedio")
hist(dfp_df$average_wait_time[dfp_df$attractions_experienced != 0], main = "Disney FastPass", xlab = "Tiempo Espera Promedio")
hist(sfp_df$average_wait_time[sfp_df$attractions_experienced != 0], main = "Salitre FastPass", xlab = "Tiempo Espera Promedio")
hist(ftp_df$average_wait_time[ftp_df$attractions_experienced != 0], main = "Tiempos Falsos", xlab = "Tiempo Espera Promedio")
```

De aquí podemos ver el como se comporta de manera general cada una de las implementaciones en cuanto el como altera las distribuciones de estos tiempos de espera.

#### **Subidas A Atracciones**

Repitamos el mismo proceso anterior pero para la cantidad promedio de veces que los visitantes del parque pudieron subierse a las atracciones.

```{r, echo = FALSE}
print(paste("Promedio atracciones subidas (Caso Base)", mean(base_df$attractions_experienced)))
print(paste("Promedio atracciones subidas (Disney FastPass)", mean(dfp_df$attractions_experienced)))
print(paste("Promedio atracciones subidas (Salite FastPass)", mean(sfp_df$attractions_experienced)))
print(paste("Promedio atracciones subidas (Tiempos Falsos)", mean(ftp_df$attractions_experienced)))
```

De manera gráfica, podemos apreciar la distribución de estos datos.

```{r, echo=FALSE, fig.align='center', fig.width=10, fig.height=7}
par(mfrow = c(2, 2))
hist(base_df$attractions_experienced, main = "Caso Base", xlab = "Subidas a las Atraciones")
hist(dfp_df$attractions_experienced, main = "Disney FastPass", xlab = "Subidas a las Atraciones")
hist(sfp_df$attractions_experienced, main = "Salitre FastPass", xlab = "Subidas a las Atraciones")
hist(ftp_df$attractions_experienced, main = "Tiempos Falsos", xlab = "Subidas a las Atraciones")
```

Veamos revisemos la cantidad de personas para cada uno de los escenarios que no pudieron subierse a ninguna atracción:

```{r, echo=FALSE}
print(paste("Personas sin subirse (Caso Base)", length(base_df$attractions_experienced[base_df$attractions_experienced == 0]) / 7))
print(paste("Personas sin subirse (Disney FastPass)", length(dfp_df$attractions_experienced[dfp_df$attractions_experienced == 0]) / 7))
print(paste("Personas sin subirse (Salitre FastPass)", length(sfp_df$attractions_experienced[sfp_df$attractions_experienced == 0]) / 7))
print(paste("Personas sin subirse (Tiempos Falsos)", length(ftp_df$attractions_experienced[ftp_df$attractions_experienced == 0]) / 7))
```

Y la cantidad de personas que pudieron subierse a al menos una atracción:

```{r, echo=FALSE}
print(paste("Personas que pudieron subirse (Caso Base)", length(base_df$attractions_experienced[base_df$attractions_experienced != 0]) / 7))
print(paste("Personas que pudieron (Disney FastPass)", length(dfp_df$attractions_experienced[dfp_df$attractions_experienced != 0]) / 7))
print(paste("Personas que pudieron (Salitre FastPass)", length(sfp_df$attractions_experienced[sfp_df$attractions_experienced != 0]) / 7))
print(paste("Personas que pudieron (Tiempos Falsos)", length(ftp_df$attractions_experienced[ftp_df$attractions_experienced != 0]) / 7))
```



### **Análisis De Los Resultados**

Procesando los diferentes resultados arrojados por las simulaciones realizadas donde se emplearon diferentes técnicas para obtener lectura de reducción o mejora de los tiempos de espera, se observaron datos bastante cercanos entre cada una de las lecturas.

 Se realiza una comparación frente a cada caso evaluado teniendo en cuenta el estudio realizado a un sistema de parque de diversiones que no presente ninguna de las alternativas nombradas en secciones anteriores, ya que en ello se basará la observación de una mejora significativa al momento de emplear los distintos modelos. Se tendrá en consideración que cada simulación se realizará con un máximo de 95.000 / 960 personas es decir más o menos 100 personas por cada 5 minutos transcurridos dentro de la simulación, esto es decir entre 37.000 y 39.000 personas en el parque por un día.

Se iniciará con la comparación de la simulación del _FastPass_ de Disney con el presente caso base, donde se observa un notorio cambio presente en las personas que no pudieron disfrutar de una atracción del parque, visualizando que entre el _FastPass_ de Disney y el caso base de un parque se tiene la diferencia de 3007 personas que pudieron disfrutar de al menos una atracción en los parques de Disney. Teniendo esto en consideración se evidencia un claro aumento en el promedio de atracciones que fueron experimentadas por los distintos usuarios que visitan al parque. Esto puede visualizarse en las gráficas presentes en la sección de resultados de la simulación dedonde se puede observar con mayor detalle.

Los tiempos de espera entre cada una de las filas de las atracciones también se vieron afectados, ya que con la implementación del _FastPass_ las personas podían disfrutar de la atracción el tiempo correspondido, haciendo que el número total de personas que no presentaron demoras en el ingreso a las distintas atracciones aumentará en comparación al modelo del parque tradicional.

Cabe resaltar que existe un ligero aumento entre los tiempos de espera de cada atracción ya que las personas que presentan la facilidad de _FastPass_ únicamente pueden saltarse la fila de la atracción deseada en un tiempo especifico haciendo que esta pueda elegir entre hacer una fila distinta para otra atracción mientras llega su turno o elegir una de las diferentes actividades a realizar en el parque.

Realizando la comparativa con la alternativa presentada por el SalitrePass contra los resultados obtenidos en el estudio del parque tradicional obtenemos una lectura con cambios perceptibles, teniendo en consideración el numero de personas que no han logrado disfrutar de una atracción dentro del parque presenta una diferencia de 1259 personas, aumentando el numero de personas que al menos disfrutaron de una atracción. Los tiempos de espera promedio también se vieron afectados ya que al tener el SalitrePass la persona puede saltarse la fila convencional e ingresar a una fila especial presentada por la misma alternativa, este presente caso puede presentar algunas averías dependiendo la cantidad de personas que presenten el SalitrePass ya que las filas pueden llegar a ser mucho mas extensas que las convencionales. 

Teniendo esto presente se observa que los tiempos de espera promedio han aumentado un aproximadamente un 15% pero se debe resaltar que las personas que no han presentado tiempo de espera son mucho mayores en el caso que presenta la alternativa del SalitrePass en comparación al parque tradicional.
El tiempo de espera máximo por atracción se observa con ligeros cambios donde los tiempos de cada atracción han aumentado en el caso presente del SalitrePass.

Tomando en consideración los datos obtenidos para el análisis del caso de tiempos falsos contra los resultados presentes en la simulación de un parque tradicional se presenta que la cantidad de personas que no han ingresado a una atracción es mucho mayor que la presente en el caso base, partiendo de esto se encuentra una diferencia de 557 personas que no pudieron ingresar a una atracción más que en el caso tradicional.

Cabe resaltar que los tiempos de espera presentes en el caso de tiempos falsos es mucho menos que el presente en el caso base, esto se debe a que, al presentar un tiempo mayor al tiempo real establecido para el ingreso a la atracción, las personas evitan emplear el tiempo presente en esperar y desean realizar cualquier otra actividad, esto hace que los tiempos de espera entre cada una de las atracciones sea menor y por lo tanto la media de ellas será inferior.

Estableciendo una comparativa entre las diferentes alternativa presentes en el estudio de parques de atracciones se pueden obtener lectura presente de una notoria diferencia entre ellas; La alternativa presentada por el SalitrePass un tiempo de espera mas bajo que los presentados por el _FastPass_ de Disney, esto debido a la capacidad que este presenta a la hora de ingresar a una atracción, pero cabe resaltar que al tener un tiempo de espera bajo la diferencia de promedio presente entre ambas es de 6.05 minutos aproximadamente, donde claramente el _FastPass_ de Disney presenta las mejores lecturas.

Hablando sobre los resultados presente en el estudio de tiempos falsos se presenta que tiene lecturas que compiten con los tiempos presentes en el SalitrePass y el _FastPass_ de Disney presentando una diferencia de 13.248 y 7.202 minutos respectivamente, pero se debe resaltar que la alternativa de tiempos falsos juega un papel sobre las personas que no presentan mayor tiempo de espera al presente en la atracción, por ello si la persona no realiza la cola los tiempos disminuyen pero un mayor número de personas no querrá ingresar a una atracción en dicho parque.


## **Conclusiones**

-	Observando los diferentes resultados obtenidos con cada uno de los casos estudiados en las simulaciones presentadas se puede concluir que las diferentes alternativas pueden ayudar a la reducción de los tiempos de espera presentes en cada parque de diversiones hasta el punto de poder combinar varias alternativas para así mejorar los tiempos de estas.

-	La alternativa que con lleva a la mayor reducción del tiempo de espera presente en cada atracción es el caso de tiempos falsos, aunque presenta un inconveniente ya que dependiendo el nivel de espera que tiene la persona se puede obtener resultados variados en cada estudio.

-	La mayor de las limitaciones presente con la alternativa de SalitrePass y tiempos falsos es que al presentar muchas personas que adquieran el SalitrePass o tengan la paciencia de esperar a los tiempos falsos se vuelven ineficientes al momento de emplearlas y pasarían a ser una cola similar a la tradicional.

## **Referencias**

-   Predecir los tiempos de espera de Disneyland a través de simulaciones de población. (s.f.). Ichi Pro. Disponible [aquí](https://ichi.pro/es/predecir-los-tiempos-de-espera-de-disneyland-a-traves-de-simulaciones-de-poblacion-36233626878710).
-   Datos sobre tiempos de espera en parque de diversiones. (s.f.). Minitab. Disponible [aquí](https://support.minitab.com/es-mx/datasets/quality-tools-data-sets/amusement-park-wait-times/).
-   Disney World Wait Times Available for Data Science and Machine Learning. (s.f.). touringplans. Disponible [aquí](https://touringplans.com/blog/disney-world-wait-times-available-for-data-science-and-machine-learning/).
-   Análisis De Líneas De Espera A Través De Teoría De Colas Y Simulación. (2010). Portilla, L. et al.
-   Managing Capacity And Flow At Theme Parks. (1996). Reza H. Ahmadi.
- Duración de las atracciones en Animal Kingdom. (s.f.). Disponible [aquí](https://touringplans.com/animal-kingdom/attractions/duration#).
- Tasa de Servicio de Animal Kingdom. Disponible [aquí](https://wdwthemeparks.com/hourly-capacity-numbers/).
- Tiempos de Espera en Animal Kingdom. Disponible [aquí](https://www.thrill-data.com/waits/park/wdw/animal-kingdom/).